# Next

- Evaluation algorithm

# Features

- Execution of actions
  - **Free execution**:
    - the user can execute actions in the order she wants by clicking directly on them in the session. However, only actions which are _executable_ (and thus do not depend on other actions) can be executed:
      - `Open`: the parent is neither introduced nor eliminated
      - `Insert`: the parent is neither introduced nor eliminated
      - `Iterate`: the target's parent is neither introduced nor eliminated, and the source is not introduced
      - `Close`: the scroll has exactly one inloop and no values in its outloop, and it is neither introduced nor used in a (de)iteration
      - `Delete`: the node is neither introduced nor used in a (de)iteration
      - `Deiterate`: the target is neither introduced nor used in a (de)iteration, and the source is not introduced

- Navigation mode
  - Each context in the navigation stack has its own actions queue

- Type/Program aliases (or macro boxes)
  - New constructor `Macro String Net` in the type `Scroll.Shape`
  - Use the double-box notation in folded form
  - Clicking on the name unfolds
  - Usual type aliases are just aliases for programs of type $\vdash \mathbf{Type}$ built with the broken cut
  - Global environment of aliases, essentially a dictionary from names to scroll nets
  - Unfolding is implemented by lookup in the global env
  - Two types of folding:
    - Given an alias name, fold every occurrence of the alias body in the session
    - Given a subnet in the session, fold with the alias found by reverse lookup
      (assuming we enforce the global env to be bijective)
  - Manipulating the global env
    - Search bar
    - Import (copy) a definition by dragging from the search results
      - If premiss non-empty, need to match it with some conclusion of a subnet located in some area (should work similarly to deiteration)
      - Actually, import may be implemented by iteration once we implement evaluation

- Linear mode
  - When enabled, auto-performs self-justification of source after (de)iteration, and
    insertion/deletion only works when followed by (de)iteration through DnD.

## Evaluation algorithm

The goal here is to implement an interpreter for scroll nets through a (currently experimental) operational semantics based on a few rewriting rules. This will make Scroller into a real programming environment, not just a proving one. For now we focus on designing an _interpreter_ for **closed** nets, i.e. where references in `justif.copy` and `justif.subcopy` always exist in the net. Ideally, we will want to design a more general _normalizer_ that also works for **open** nets, so that the user can restrict evaluation to a selected or focused subnet.

Without further ado, here is the high-level description of the algorithm.

It is separated in three phases, corresponding to three sets of rewriting rules: `Copy`, `Free` and
`Return`. Each phase is a function of type `Net -> Net` (functions `copy`, `free` and `return` in `Model.Scroll`) which applies the rewriting rules eagerly by traversing the net in a specific manner. The evaluation algorithm is simply the fixpoint of the composition `copy >> free >> return` of these 3 phases.

### The Linker (`Copy` phase)

The Linker's responsibility is to remove dependencies in `justif.copy`/`justif.subcopy` fields created by (de)iteration actions. This is done by inlining/duplicating/transporting proof annotations (corresponding to recorded actions) from the referenced source node into the target copy node, then removing the reference by setting the field to `Nothing`.

To do this correctly and efficiently, we decompose linking into 2 cases that perform tree rotations on the dependency/justification forest generated by `copy` references.

For every non-root leaf of the forest (i.e. nodes who are not referenced by any other nodes):

1. **(Recursive case)** if its parent is not a root, then we relink the leaf to be directly a copy of its grand-parent. Furthermore if the leaf is Sep-shaped, we transport all annotations from subnodes (i.e. descendents in the "place tree" generated by `Node.context` and `Sep children _`) of the parent to the corresponding subnodes of the leaf, by following `subcopy` links and then resetting them to `Nothing`. The transport will be achieved with the `Scroll.mergeNodes` function.

2. **(Base case)** if its parent is a sep-shaped root with an `opened == True` interaction, then we set the leaf's `copy` field to `Nothing` and its interaction to `opened == True` so that it becomes itself an opened root, and perform the transport operation as in step 1.

### The Garbage Collector (`Free` phase)

The Garbage Collector's responsibility is to remove nodes that are self-justified copies not referenced by any other nodes.

Like the Linker, it proceeds from leaves to roots in the justification forest:

1. **(Recursive case)** every non-root self-justified leaf is simply removed from the `net.nodes` dictionary.

2. **(Base case)** every self-justified sep-shaped root with an `opened == True` interaction is also removed from `net.nodes`.


### The Stack Manager (`Return` phase)

The Stack Manager's responsibility is to collapse scrolls with an `{ opened = True, closed = True }` interaction, which are akin to function calls in traditional programming languages.

This simply proceeds by traversing `net.nodes`, calling `Scroll.removeScrollNodes` accordingly.


# Brainstorming

## Names

### Variables

Note: this is currently irrelevant/obsolete, since we do not have variables, only identifiers + non-semantic names. I just keep the discussion in case this design decision turns out to be untenable.

- Two options for shadowing:
  1. **Yes:** name uniqueness is only required locally or "horizontally", i.e. in the same area/address space. Then in order to still allow every (well-scoped) iteration, we should use a named De Bruijn representation, where a variable $(x, n)$ refers to the variable $x$ occurring in the $n$-th outer cut area. **We also need to ensure operations that insert or remove nodes update indices accordingly**. Frontend-wise, the index should be visible but unobtrusive, maybe using an on-demand disambiguation mechanism like source hover on highlighting. Then there is no shadowing stricto sensu, but we can achieve an observationally indistinguishable user experience by hiding the index $n$ if there is no bound variable with name $x$ in the $i$-th outer cut area for every $i < n$.
  2. **No:** name uniqueness is required for every union of areas/address spaces in the same scope. Then we do not need De Bruijn indices, but the burden of maintaining index consistency becomes that of maintaining scope-wise uniqueness. While it may actually be simpler to implement correctly (e.g. no shifting), it does deprive the user from some naming freedom. But some people argue that shadowing is just bad practice, so it may be wiser to go for the simplest option and see if anyone complains later on.

- Maintain uniqueness of same-scope bound variables in various operations
  - Function `bvu` (bound vars upward) that computes the bound variables available at a given `Path`
  - Function `bvd` (bound vars downward) that computes all the bound variables in scope of a given `Path`
  - Notice that $\mathsf{bv} = \mathsf{bvu} \cap \mathsf{bvd}$, where `bv` is the set of variables bound precisely in the area of the `Path`
  - All actions that introduce a new node (`Open`/`Insert`/`Iterate`):
    - can compute a fresh name automatically, or can ask the user for a name and deny it if it is already in `bvu ∪ bvd`
  - All actions that change the scope of a binder (`Close`)
    - can compute fresh names automatically for all bound vars in the inloop, or can ask the user to rename all those that are already in `bvd`
  - Renaming
    - check that the new name is not already in `bvu ∪ bvd`

### Non-semantic names

I want a notion of « frontend » name for nodes, that is orthogonal to the notion of node identifier (NodeId) living purely in the backend and invisible to the user.

So by default, nodes do not have a name. But still, we do not want to display the argumentation with arrows as in the diagrammatic notation for scroll nets, because it would make the layouting algorithm way too difficult to implement (or even specify). I imagine an interactive display mechanism: when the user hovers some justified target node, its source becomes highlighted. This supposes that it is visible on screen at the same time as the target. In case it is not, we could rely on the shelf mechanism that I plan to implement later. In a nutshell, the shelf is a scrollable (in the UI sense) area of the UI which holds all the nodes that are available in the currently focused subnet. This assumes that we have implemented the Navigation mode allowing to navigate scroll nets by zooming in or out of subnets, which I imagine implementing ideally as a ZUI. Then the source would always be somewhere in the shelf, and would first be scrolled to if not visible yet, then highlighted. One could also directly focus the subnet holding the source in the main view, indeed a form of « jump to definition ».

But we’re getting led astray here. The purpose of names is to give a more traditional, symbolic mechanism for tracking provenance of data/justification, just like variables. However since it is independent from the actual proof object stored internally, these names do not really hold any semantic value. This gives the user the freedom to name nodes however they want in principle, and we shall indeed refrain from implementing any restriction at first for the sake of simplicity. For instance, variable shadowing can trivially be done in this context. Later on, one might want to impose (or at least suggest) some good naming practices to the user, the most basic one being to avoid giving the same name to different nodes in the same subnet.

## Modularity

In our first implementation, we will only have one big program that cannot interact neither with the external world (i.e. "side-effects" like I/O, network, etc), nor even with other Scroller programs.

Later on, we will want to have a notion of **module** allowing to export and import functionalities from other programs. The right way to do so is very non-obvious, as it would (at least traditionally) crucially depends on how we manage identifiers and names.

One inspiration is how it is actually done in Elm with `export/import ... exposing (...)`. If we stick to the intended separation between backend identifiers and frontend names, then the content that is exposed is really just the identifier and its content.

Then comes the question of what to do with dependencies of the exposed content. A priori they should not be exposed themselves, but still be linked somehow so that evaluation does not get stuck.

Now let's consider an example. I import the addition function `add` from some external module, and just iterate it once without applying it. There are (at least) two possibilities for the semantics of import:

1. The original copy of `add` is inlined in the current program. Then evaluation will perform the copy and remove the dependency to the inlined copy. The implementation of `add` is visible to the user in the inlined copy before evaluation, and in both copies after.
2. An iterated copy of `add` is inlined in the current program, with a special kind of external dependency so that the `from` ID is not a dangling pointer. Then evaluation gets stuck, except if we implement a mechanism to fetch external dependencies. In that case, the implementation of `add` is visible to the user in neither of the copies before evaluation, and in both copies after.

It seems that in both cases, the implementation of `add` is revealed after evaluation. But in a traditional (functional) language, the implementation of `add` would still be hidden after evaluation. So basically, it seems there is no obvious way to have a separation between evaluation and linking phases.

I wonder how this is actually handled in proof assistants. For instance, it seems to me that every imported definition in Rocq can have its implementation exposed with `Print`, although `Compute` will not unfold the definition.

A trivial workaround is if `add` is a primitive function of Scroller. Then by "definition" (i.e. it is hardcoded in Scroller), it only evaluates when both arguments are given and the scroll is closed.
